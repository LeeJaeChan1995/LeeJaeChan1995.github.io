# 큰 수의 법칙
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙<br>

단, 배열의 특정한 인덱스에 해당하는 요소가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징<br>

예) 3, 8, 6, 2, 9의 값으로 이루어진 배열이 있을 때 M = 7, K = 2<br>

위와 같은 경우 총 일곱 번의 덧셈을 하며, 특정 인덱스에 해당하는 수가 연속해서 두 번까지 더해질 수 있다<br>

결과 : 9 + 9 + 8 + 9 + 9 + 8 + 9 = 61<br>

[입력 조건]

* 첫째 줄에 N (2 ≤ N ≤ 1000), M (1 ≤ M ≤ 10000), K(1 ≤ K ≤ 10000)의 자연수가 주어지며, 공백으로 구분

* 둘째 줄에 N개의 자연수가 주어지며, 각 자연수는 공백으로 구분

  단, 각각의 자연수는 1 이상 10000 이하의 수

* 입력으로 주어지는 K는 항상 M보다 작거나 같다

[출력 조건]

* 첫째 줄에 큰 수의 법칙에 따라 더해진 답을 출력

| - 입력 예시          | - 출력 예시 |
| -------------------- | ----------- |
| 5 8 3<br />2 4 5 4 6 | 46          |

```python
arr_n, M, k = map(int,input().split())
arr = list(map(int, input().split()))

for i in range(arr_n-1):
    if i < len(arr):
        if arr[i] > arr[i+1]:
            temp = arr[i]
            arr[i], arr[i+1] = arr[i+1], temp

arr_sum = 0 # M번의 덧셈 연산의 결과를 담을 변수
arr_count = 0 # K번 만큼 더해주어야 할 마지막 인덱스의 카운트

for j in range(M):
    if k != arr_count:
        arr_sum = arr_sum + arr[-1]
        arr_count += 1
    else:
        arr_sum = arr_sum + arr[-2]
        arr_count = 0

print(arr_sum)

```

첫 번째 반복문은 파이썬에서 기본으로 제공해주는 리스트의 메서드인 sort()와 같은 동작을 수행한다<br>

(sort()를 사용할 수 있지만, 직접 구현해보는게 의미가 있을 것 같아서 연습삼아 만들어보았다)<br>

<br>

두 번째 반복문에서 조건에 따른 덧셈 연산을 기능하게 된다<br>

조건을 다시 한 번 살펴보면 "입력된 배열의 요소 중 주어진 M 값 만큼 더하여 <u>__가장 큰 수__</u>를 만들어야 한다<br>

이 때, <u>__특정 인덱스__</u>의 수는 <u>__연속해서 K번까지만__</u> 더해질 수 있다" 고 한다<br>

<br>

입력된 배열의 요소 중 가장 큰 수, 첫 번째 반복문을 통해 정렬된 리스트의 가장 마지막 인덱스의 요소를 M번 만큼 더해주면 해당 리스트의 요소로 만들 수 있는 수 중 가장 클 것이다<br>

이 때, 이 마지막 인덱스의 요소를 연속해서 K번까지만 더할 수 있다고 하는 것이므로 K번 만큼 더한 이후 한 번의 연산은 마지막 인덱스의 -1번째 인덱스의 요소를 더해주어야 할 것이다<br>

<br>

다시 위의 코드를 보면, 첫 번째 반복문이 끝난 후 M번 만큼 더한 결과를 담기 위한 변수 arr_sum과 마지막 인덱스를 K번 만큼 더할 수 있게 도와줄 카운트 변수 arr_count를 각각 초기값 0으로 선언해주었다<br>

이후 두 번째 반복문으로 들어오게 되면 입력된 M번 만큼 반복하며, 각 조건에 맞는 덧셈을 수행하게 된다<br>

만약 arr_count, 마지막 인덱스에 덧셈 연산의 반복이 K 값 보다 작다면 마지막 인덱스 값을 더해주고 카운트를 1증가 시키며, arr_count가 K 값과 같다면 마지막 인덱스의 <u>__-1번째 인덱스의 요소__<u>를 더하고 카운트를 다시 0으로 초기화 시킨다<br>

(카운트를 초기화시키는 과정을 반복문의 지연 변수인 j로 하지 않는 이유는 j는 range(M)번이 될 때까지 <u>__무조건__</u> 1씩 계속해서 증가하기 때문에 0으로 초기화를 할 수가 없으며, % 연산을 사용해서 K 값과 비교할 수 있지만 추가적인 조건이 필요할 것 같아서 위와 같은 방법으로 진행하게 되었다)<br>

<br>

위 조건에 맞추어 해당 반복문은 M번의 덧셈 연산을 마치고 arr_sum을 최종적으로 출력하게 된다

 



